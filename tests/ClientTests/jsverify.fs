// autogenerated : ts2fable node_modules/jsverify/lib/jsverify.d.ts jsverify.fs
// ts2fable 0.0.0
module rec jsverify
open System
open Fable.Core
open Fable.Import.JS

let [<Import("*","jsverify")>] jSVerify: JSVerify.IExports = jsNative

module JSVerify =

    type [<AllowNullLiteral>] IExports =
        abstract bless: arb: ArbitraryLike<'U> -> Arbitrary<'U>
        abstract sampler: arb: Arbitrary<'U> * ?genSize: float -> (float -> 'U)
        abstract small: arb: Arbitrary<'U> -> Arbitrary<'U>
        abstract suchthat: arb: Arbitrary<'U> * predicate: ('U -> bool) -> Arbitrary<'U>
        abstract integer: obj
        abstract nat: obj
        abstract number: obj
        abstract uint8: Arbitrary<float>
        abstract uint16: Arbitrary<float>
        abstract uint32: Arbitrary<float>
        abstract int8: Arbitrary<float>
        abstract int16: Arbitrary<float>
        abstract int32: Arbitrary<float>
        abstract bool: Arbitrary<bool>
        abstract datetime: Arbitrary<DateTime>
        abstract elements: args: ResizeArray<'T> -> Arbitrary<'T>
        abstract falsy: Arbitrary<obj option>
        abstract constant: x: 'T -> Arbitrary<'T>
        abstract char: Arbitrary<string>
        abstract asciichar: Arbitrary<string>
        abstract string: Arbitrary<string>
        abstract nestring: Arbitrary<string>
        abstract asciistring: Arbitrary<string>
        abstract asciinestring: Arbitrary<string>
        abstract nonShrink: arb: Arbitrary<'T> -> Arbitrary<'T>
        abstract either: arbA: Arbitrary<'T> * arbB: Arbitrary<'U> -> Arbitrary<U2<'T, 'U>>
        abstract pair: arbA: Arbitrary<'T> * arbB: Arbitrary<'U> -> Arbitrary<'T * 'U>
        abstract tuple: arbs: ResizeArray<Arbitrary<obj option>> -> Arbitrary<ResizeArray<obj option>>
        abstract sum: arbs: ResizeArray<Arbitrary<obj option>> -> Arbitrary<obj option>
        abstract dict: arb: Arbitrary<'T> -> Arbitrary<obj>
        abstract array: arb: Arbitrary<'T> -> Arbitrary<ResizeArray<'T>>
        abstract nearray: arb: Arbitrary<'T> -> Arbitrary<ResizeArray<'T>>
        abstract fn: arb: Arbitrary<'T> -> Arbitrary<(obj option -> 'T)>
        abstract ``fun``: arb: Arbitrary<'T> -> Arbitrary<(obj option -> 'T)>
        abstract json: Arbitrary<obj option>
        abstract unit: Arbitrary<obj option>
        abstract oneof: gs: ResizeArray<Arbitrary<'T>> -> Arbitrary<'T>
        abstract record: arbs: obj -> Arbitrary<'T>
        abstract forall: arb1: Arbitrary<'A> * prop: ('A -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * prop: ('A -> 'B -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * prop: ('A -> 'B -> 'C -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * prop: ('A -> 'B -> 'C -> 'D -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> Property<'T>) -> Property<'T>
        abstract forall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * arb10: Arbitrary<'J> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> 'J -> Property<'T>) -> Property<'T>
        abstract forall: [<ParamArray>] args: ResizeArray<obj option> -> Property<obj option>
        abstract assertForall: arb1: Arbitrary<'A> * prop: ('A -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * prop: ('A -> 'B -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * prop: ('A -> 'B -> 'C -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * prop: ('A -> 'B -> 'C -> 'D -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> Property<'T>) -> 'T
        abstract assertForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * arb10: Arbitrary<'J> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> 'J -> Property<'T>) -> 'T
        abstract assertForall: [<ParamArray>] args: ResizeArray<obj option> -> obj option
        abstract checkForall: arb1: Arbitrary<'A> * prop: ('A -> Property<'A>) -> Result<'A>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * prop: ('A -> 'B -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * prop: ('A -> 'B -> 'C -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * prop: ('A -> 'B -> 'C -> 'D -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> Property<obj option>) -> Result<obj option>
        abstract checkForall: arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * arb10: Arbitrary<'J> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> 'J -> Property<obj option>) -> Result<obj option>
        abstract checkForall: [<ParamArray>] args: ResizeArray<obj option> -> Result<obj option>
        abstract property: description: String * arb1: Arbitrary<'A> * prop: ('A -> Property<'A>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * prop: ('A -> 'B -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * prop: ('A -> 'B -> 'C -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * prop: ('A -> 'B -> 'C -> 'D -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> Property<obj option>) -> obj option
        abstract property: description: String * arb1: Arbitrary<'A> * arb2: Arbitrary<'B> * arb3: Arbitrary<'C> * arb4: Arbitrary<'D> * arb5: Arbitrary<'E> * arb6: Arbitrary<'F> * arb7: Arbitrary<'G> * arb8: Arbitrary<'H> * arb9: Arbitrary<'I> * arb10: Arbitrary<'J> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> 'J -> Property<obj option>) -> obj option
        abstract property: [<ParamArray>] args: ResizeArray<obj option> -> Result<obj option>
        abstract check: prop: Property<'T> * ?opts: Options -> Result<'T>
        abstract ``assert``: prop: Property<'T> * ?opts: Options -> 'T
        abstract generator: GeneratorFunctions
        abstract shrink: ShrinkFunctions
        abstract show: ShowFunctions
        abstract random: Random

    type [<AllowNullLiteral>] Arbitrary<'T> =
        interface end

    type [<AllowNullLiteral>] ArbitraryLike<'T> =
        abstract generator: Generator<'T> with get, set
        abstract show: Show<'T> option with get, set
        abstract shrink: Shrink<'T> option with get, set

    type [<AllowNullLiteral>] ArbitraryFns<'T> =
        abstract smap: f: ('T -> 'U) * g: ('U -> 'T) * ?newShow: Show<'U> -> Arbitrary<'U>

    type [<AllowNullLiteral>] Options =
        abstract tests: float option with get, set
        abstract size: float option with get, set
        abstract quiet: bool option with get, set
        abstract rngState: string option with get, set

    type [<AllowNullLiteral>] Result<'T> =
        abstract counterexample: 'T with get, set
        abstract tests: float with get, set
        abstract shrinks: float with get, set
        abstract exc: string option with get, set
        abstract rngState: string with get, set

    type [<AllowNullLiteral>] Generator<'T> =
        interface end

    type [<AllowNullLiteral>] GeneratorFn<'T> =
        [<Emit "$0($1...)">] abstract Invoke: size: float -> 'T

    type [<AllowNullLiteral>] GeneratorFns<'T> =
        abstract map: f: ('T -> 'U) -> Generator<'U>
        abstract flatmap: f: ('T -> Generator<'U>) -> Generator<'U>

    type [<AllowNullLiteral>] Shrink<'T> =
        interface end

    type [<AllowNullLiteral>] ShrinkFn<'T> =
        [<Emit "$0($1...)">] abstract Invoke: t: 'T -> ResizeArray<'T>

    type [<AllowNullLiteral>] ShrinkFns<'T> =
        abstract smap: f: ('T -> 'U) * g: ('U -> 'T) -> Shrink<'U>

    type [<AllowNullLiteral>] Show<'T> =
        [<Emit "$0($1...)">] abstract Invoke: t: 'T -> string

    type Property<'T> =
        U3<bool, unit, 'T>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module Property =
        let ofBool v: Property<'T> = v |> U3.Case1
        let isBool (v: Property<'T>) = match v with U3.Case1 _ -> true | _ -> false
        let asBool (v: Property<'T>) = match v with U3.Case1 o -> Some o | _ -> None
        let ofUnit v: Property<'T> = v |> U3.Case2
        let isUnit (v: Property<'T>) = match v with U3.Case2 _ -> true | _ -> false
        let asUnit (v: Property<'T>) = match v with U3.Case2 o -> Some o | _ -> None
        let ofT v: Property<'T> = v |> U3.Case3
        let isT (v: Property<'T>) = match v with U3.Case3 _ -> true | _ -> false
        let asT (v: Property<'T>) = match v with U3.Case3 o -> Some o | _ -> None

    type [<AllowNullLiteral>] integerFn =
        [<Emit "$0($1...)">] abstract Invoke: maxsize: float -> Arbitrary<float>

    type [<AllowNullLiteral>] integerFn2 =
        [<Emit "$0($1...)">] abstract Invoke: minsize: float * maxsize: float -> Arbitrary<float>

    type [<AllowNullLiteral>] GeneratorFunctions =
        abstract constant: u: 'U -> Generator<'U>
        abstract oneof: gens: ResizeArray<Generator<'U>> -> Generator<'U>
        abstract recursive: genZ: Generator<'U> * f: ('U -> 'U) -> Generator<'U>
        abstract pair: genA: Generator<'T> * genB: Generator<'U> -> Generator<'T * 'U>
        abstract either: genA: Generator<'T> * genB: Generator<'U> -> Generator<U2<'T, 'U>>
        abstract tuple: gens: ResizeArray<Generator<obj option>> -> Generator<ResizeArray<obj option>>
        abstract sum: gens: ResizeArray<Generator<obj option>> -> Generator<obj option>
        abstract array: gen: Generator<'U> -> Generator<ResizeArray<'U>>
        abstract nearray: gen: Generator<'U> -> Generator<ResizeArray<'U>>
        abstract dict: gen: Generator<'U> -> Generator<obj>
        abstract unit: Generator<obj option> with get, set
        abstract bless: genLike: GeneratorFn<'T> -> Generator<'T>
        abstract small: gen: Generator<'T> -> Generator<'T>
        abstract combine: arb1: Generator<'A> * prop: ('A -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * prop: ('A -> 'B -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * prop: ('A -> 'B -> 'C -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * prop: ('A -> 'B -> 'C -> 'D -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * arb5: Generator<'E> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * arb5: Generator<'E> * arb6: Generator<'F> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * arb5: Generator<'E> * arb6: Generator<'F> * arb7: Generator<'G> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * arb5: Generator<'E> * arb6: Generator<'F> * arb7: Generator<'G> * arb8: Generator<'H> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * arb5: Generator<'E> * arb6: Generator<'F> * arb7: Generator<'G> * arb8: Generator<'H> * arb9: Generator<'I> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> 'R) -> Generator<'R>
        abstract combine: arb1: Generator<'A> * arb2: Generator<'B> * arb3: Generator<'C> * arb4: Generator<'D> * arb5: Generator<'E> * arb6: Generator<'F> * arb7: Generator<'G> * arb8: Generator<'H> * arb9: Generator<'I> * arb10: Generator<'J> * prop: ('A -> 'B -> 'C -> 'D -> 'E -> 'F -> 'G -> 'H -> 'I -> 'J -> 'R) -> Generator<'R>
        abstract combine: [<ParamArray>] args: ResizeArray<obj option> -> Generator<'R>

    type [<AllowNullLiteral>] ShrinkFunctions =
        abstract noop: Shrink<obj option> with get, set
        abstract pair: shrA: Shrink<'T> * shrB: Shrink<'U> -> Shrink<'T * 'U>
        abstract either: shrA: Shrink<'T> * shrB: Shrink<'U> -> Shrink<U2<'T, 'U>>
        abstract tuple: shrs: ResizeArray<Shrink<obj option>> -> Shrink<ResizeArray<obj option>>
        abstract sum: shrs: ResizeArray<Shrink<obj option>> -> Shrink<obj option>
        abstract array: shr: Shrink<'T> -> Shrink<ResizeArray<'T>>
        abstract nearray: shr: Shrink<'T> -> Shrink<ResizeArray<'T>>
        abstract bless: shrinkLike: ShrinkFn<'T> -> Shrink<'T>

    type [<AllowNullLiteral>] ShowFunctions =
        abstract def: x: 'T -> string
        abstract pair: sA: Show<'T> * sB: Show<'U> * x: 'T * 'U -> string
        abstract either: sA: Show<'T> * sB: Show<'U> * x: U2<'T, 'U> -> string
        abstract tuple: shs: ResizeArray<Show<obj option>> * x: ResizeArray<obj option> -> string
        abstract sum: shs: ResizeArray<Show<obj option>> * x: obj option -> string
        abstract array: sh: Show<'T> * x: ResizeArray<'T> -> string

    type [<AllowNullLiteral>] Random =
        interface end

    type [<AllowNullLiteral>] RandomInt =
        [<Emit "$0($1...)">] abstract Invoke: min: float * max: float -> float

    type [<AllowNullLiteral>] RandomFunctions =
        abstract number: min: float * max: float -> float
